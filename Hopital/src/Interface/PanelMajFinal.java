/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package Interface;

import javax.swing.*;
import BBDspéc.*;
import Connection.ConnectionEce;
import Connection.*;
import DAO.DAO;
import DAO.EmployeDAO;
import BBDspéc.Batiment;
import DAO.*;
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JOptionPane;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;

/**
 *
 * @author travail
 */
public class PanelMajFinal extends javax.swing.JPanel {

    private String requeteChoisie = "0";
    private ConnectionEce conn1;//= new ConnectionEce("0","","",""); //erreur
    private ArrayList tabVal = new ArrayList();

    private Object MAJTableau[];
    private JTable leTableau = new JTable();
    private DefaultTableModel modelTabGlobal = new DefaultTableModel();
    private JScrollPane scrollPane11 = new JScrollPane(leTableau);

    private EmployeDAO retourEmployeAll = new EmployeDAO(ConnectionEce.getConn());
    private DocteurDAO retourDocteurAll = new DocteurDAO(ConnectionEce.getConn());
    private ChambreDAO retourChambreAll = new ChambreDAO(ConnectionEce.getConn());

    boolean affTabEMp = false; //pour raffraichir le tableau
    boolean affTabDoc = false;
     boolean affTabCH = false;

    public PanelMajFinal(ConnectionEce connIN) {
        initComponents();
        conn1 = connIN;
        //Ajout du scrollPane dans le JPanel
        scrollPane11 = new JScrollPane(leTableau);
        this.add(scrollPane11);
        scrollPane11.setBounds(50, 180, 1100, 500);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">                          
    private void initComponents() {

        jButton1 = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jComboBox1 = new javax.swing.JComboBox();
        jButton2 = new javax.swing.JButton();
        jButton3 = new javax.swing.JButton();
        jButton4 = new javax.swing.JButton();
        jTextField1 = new javax.swing.JTextField();

        jButton1.setText("MAJ");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jLabel2.setText("AFFICHAGE ET MISE A JOUR DE VOS DONNEES");

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[]{"Table à afficher", "Batiment", "Chambre", "Docteur", "Employe", "Infirmier", "Hospitalisation", "Malade", "Service", "Soigne", "Requête 10"}));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jButton2.setText("Insérer");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jButton3.setText("Supprimer");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        jButton4.setText("Aide");
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jTextField1.setText("Indice");
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                        .addGap(83, 83, 83)
                                        .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                        .addGap(33, 33, 33)
                                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                                .addGroup(layout.createSequentialGroup()
                                                        .addComponent(jButton4)
                                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                        .addComponent(jButton3)
                                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                                        .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                                                .addGroup(layout.createSequentialGroup()
                                                        .addComponent(jButton1)
                                                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                                                        .addComponent(jButton2))))
                                .addGroup(layout.createSequentialGroup()
                                        .addGap(163, 163, 163)
                                        .addComponent(jLabel2)))
                        .addContainerGap(155, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                .addGroup(layout.createSequentialGroup()
                        .addGap(18, 18, 18)
                        .addComponent(jLabel2)
                        .addGap(15, 15, 15)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jButton1)
                                .addComponent(jComboBox1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addComponent(jButton2))
                        .addGap(18, 18, 18)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                                .addComponent(jButton3)
                                .addComponent(jButton4)
                                .addComponent(jTextField1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                        .addContainerGap(392, Short.MAX_VALUE))
        );
    }// </editor-fold>                        

    private void jComboBox1ActionPerformed(java.awt.event.ActionEvent evt) {
        requeteChoisie = (String) jComboBox1.getSelectedItem();
    }

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {
        /*OBJECTIF:
         Selon la requête, remplir un ArrayList tabVal. 
         Il permettra de remplir un tableauModel de l'interface.*/
        System.out.println("La table choisie est " + requeteChoisie);
    
        switch (requeteChoisie) {
            case "Employe": {
                //si le tableau n'a pas encore été défini
                if (affTabEMp == false) {//réception des valeurs de la table
                    ArrayList<Employe> tabVal1 = retourEmployeAll.findall();
                    //entetes du tableau
                    String[] entetes = {"No employé", "Nom", "Prénom", "Tel", "Adresse"};
                   //mise en place du Model du tableau
                    //modification du model stocké
                   DefaultTableModel tableModel = new DefaultTableModel(entetes, 0);
                   //nécessaire sinon les model s'ajoutent les uns après les autres.          
                    //modification du model stocké
                    modelTabGlobal =tableModel;
                    modelTabGlobal.setColumnIdentifiers(entetes);
                   //allocation de MAJTableau=> stockage pour utilisation future
                   
                    MAJTableau = new Object[tabVal1.size()];
                    //remplissage des data => objectTab          
                    for (int i = 0; i < tabVal1.size(); i++) {
                        Employe emp = new Employe();
                        emp = (Employe) tabVal1.get(i);
                        Object objectTab[] = { //objectTab permet de remplir le JTable
                            emp.getNo_employe(),
                            emp.getNom(),
                            emp.getPrenom(),
                            emp.getTel(),
                            emp.getAdresse()
                        };
                        MAJTableau[i] = objectTab;
                        modelTabGlobal.addRow(objectTab);
                    }
                //modelTabGlobal = tableModel;
                    //permet de changer le model du tableau  
                    leTableau.setModel(modelTabGlobal);
                //Ajout du scrollPane dans le JPanel
                /*scrollPane11 = new JScrollPane(leTableau);
                     this.add(scrollPane11);  
                     scrollPane11.setBounds(50,180,1100,500);*/
                    //Test de sortie
                    System.out.println("Test Find All Employe Fin");

                    /* modelTabGlobal.addTableModelListener( new TableModelListener(){
                     @Override
                     public void tableChanged(TableModelEvent e) {
                     // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                     updateFonctionEmp();
                     }
                     });*/
          //Le tableau a déjà été chargé une fois. on modifie le booléen de test pour pourvoir
                    //raffraichir le panel      
                    affTabEMp = true;
                    affTabDoc = false;
                    affTabCH = false;
                }
            }
            break;
            /**
             * ***************************************
             *///////////////
            case "Docteur": {
                //si le tableau n'a pas encore été défini
                if (affTabDoc == false) {//réception des valeurs de la table
                    
                    //réception des valeurs de la table
                    
                    ArrayList<Docteur> tabVal1 = retourDocteurAll.findall();
                    //entetes du tableau
                    String[] entetes = {"No employé", "Nom", "Prénom", "Tel", "Adresse", "Specialite"};
                   //mise en place du Model du tableau
                    DefaultTableModel tableModel = new DefaultTableModel(entetes, 0);
                    //modification du model stocké
                    modelTabGlobal =tableModel;
                    modelTabGlobal.setColumnIdentifiers(entetes);
                   //allocation de MAJTableau=> stockage pour utilisation future
                    // System.out.println(" "+tabVal1.size());//test pour la taille du tableau
                    
                    MAJTableau = new Object[tabVal1.size()];
                    //remplissage des data => objectTab          
                    for (int i = 0; i < tabVal1.size(); i++) {
                        Docteur emp = new Docteur();
                        emp = (Docteur) tabVal1.get(i);
                        Object objectTab[] = { //objectTab permet de remplir le JTable
                            emp.getNo_employe(),
                            emp.getNom(),
                            emp.getPrenom(),
                            emp.getTel(),
                            emp.getAdresse(),
                            emp.getSpecialite()
                        };
                        MAJTableau[i] = objectTab;
                        modelTabGlobal.addRow(objectTab);
                    }
                //modelTabGlobal = tableModel;
                    //permet de changer le model du tableau  
                    leTableau.setModel(modelTabGlobal);

//Test de sortie
                    System.out.println("Test Find All Docteur Fin");

           
          //Le tableau a déjà été chargé une fois. on modifie le booléen de test pour pourvoir
                    //raffraichir le panel      
                    affTabDoc = true;
                    affTabEMp = false;
                    affTabCH = false;
                }
            }
            break;
            case "Chambre":
                //si le tableau n'a pas encore été défini
                if (affTabCH == false) {//réception des valeurs de la table
                    //réception des valeurs de la table
                    ArrayList<Chambre> tabVal1 = retourChambreAll.findall();
                    //entetes du tableau
                    String[] entetes = {"Code Service", "N. Chambre", "Nn_lits", "Surveillant"};
                   //mise en place du Model du tableau
                    DefaultTableModel tableModel = new DefaultTableModel(entetes, 0);
                    //modification du model stocké
                    modelTabGlobal =tableModel;                    //modification du model stocké
                    modelTabGlobal.setColumnIdentifiers(entetes);
                   //allocation de MAJTableau=> stockage pour utilisation future
                    // System.out.println(" "+tabVal1.size());//test pour la taille du tableau
                    MAJTableau = new Object[tabVal1.size()];
                    //remplissage des data => objectTab          
                    for (int i = 0; i < tabVal1.size(); i++) {
                        Chambre emp = new Chambre();
                        emp = (Chambre) tabVal1.get(i);
                        Object objectTab[] = { //objectTab permet de remplir le JTable
                            emp.getCode_service(),
                            emp.getNo_chambre(),
                            emp.getNb_lits(),
                            emp.getSurveillant(),
                        };
//String code_service, int no_chambre, int surveillant, int nb_lits

                        MAJTableau[i] = objectTab;
                        modelTabGlobal.addRow(objectTab);
                    }
                //modelTabGlobal = tableModel;
                    //permet de changer le model du tableau  
                    leTableau.setModel(modelTabGlobal);

//Test de sortie
                    System.out.println("Test Find All Chambre Fin");
                affTabDoc = false;
                affTabEMp = false;
                affTabCH = true; 
                break;
        }
        /*il y avait un problème lié au rappel (deuxième tour du switch). 
         La création d'une autre table lançait un update qui la contrecarrait.*/
         
        modelTabGlobal.addTableModelListener(new TableModelListener() {
            @Override
            public void tableChanged(TableModelEvent e) {
           // throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
                //si l'événement est bien une update et si ce n'est pas l'update de l en tete

                if (e.getType() == TableModelEvent.UPDATE && e.getFirstRow() != TableModelEvent.HEADER_ROW) {
                    updateFonctionEmp(); //alors on lance l'update.
                }
            }
        });
    } 
      
}

    public void updateFonctionEmp() {
        switch (requeteChoisie) {

            case "Employe": {
                //créer l'objet Employe à envoyer pour l'update
                Employe MAJEmployRecu = new Employe();
                //regarde là où l'utilisateur effectue la modification dans le tableau
                int ligne = leTableau.getSelectedRow();//Si tu veut la cellule selectionnée, sinon une autre valeur
                int colonne = leTableau.getSelectedColumn();//Si tu veut la cellule selectionnée, sinon une autre valeur
                Object cellule = leTableau.getValueAt(ligne, colonne);
                String currentVal = (String) cellule;
           //"No employé","Nom", "Prénom", "Tel", "Adresse":=> 5 colonnes
                //enregistre les informations de l'employe de la ligne où l'utilisateur  
                //effectue des modifications
                int curNo = (Integer) leTableau.getValueAt(ligne, 0); //d'abord le N°
                MAJEmployRecu.setNo_employe(curNo);
                //puis les autres attributs String
                for (int i = 1; i < 5; i++) {
                    String curVal = (String) leTableau.getValueAt(ligne, i);
                    switch (i) {
                        case 1:
                            MAJEmployRecu.setNom(curVal);
                            break;
                        case 2:
                            MAJEmployRecu.setPrenom(curVal);
                            break;
                        case 3:
                            MAJEmployRecu.setTel(curVal);
                            break;
                        case 4:
                            MAJEmployRecu.setAdresse(curVal);
                            break;
                        default:
                            break;
                    }
                }
           //le programme regarde dans quelle colonne est effectuée la modification
                //en fonction, il détermine quel attribut a changé
                //et l'enregistre dans l'employé correspondant
                switch (colonne) {
                    case 0:
                        MAJEmployRecu.setNo_employe(Integer.parseInt(currentVal));
                        break;
                    case 1:
                        MAJEmployRecu.setNom(currentVal);
                        break;
                    case 2:
                        MAJEmployRecu.setPrenom(currentVal);
                        break;
                    case 3:
                        MAJEmployRecu.setTel(currentVal);
                        break;
                    case 4:
                        MAJEmployRecu.setAdresse(currentVal);
                        break;
                    default:
                        break;
                }
                //l'instance modifiée de la classe Employé et ensuite envoyée pour update
                retourEmployeAll.update(MAJEmployRecu);
            }
            break;
            case "Docteur": {
                //créer l'objet Employe à envoyer pour l'update
                Docteur MAJEmployRecu = new Docteur();
                //regarde là où l'utilisateur effectue la modification dans le tableau
                int ligne = leTableau.getSelectedRow();//Si tu veut la cellule selectionnée, sinon une autre valeur
                int colonne = leTableau.getSelectedColumn();//Si tu veut la cellule selectionnée, sinon une autre valeur
                Object cellule = leTableau.getValueAt(ligne, colonne);
                String currentVal = (String) cellule;
                int curNo = (Integer) leTableau.getValueAt(ligne, 0); //d'abord le N°
                MAJEmployRecu.setNo_employe(curNo);
                //puis les autres attributs String
                for (int i = 1; i < 6; i++) {
                    String curVal = (String) leTableau.getValueAt(ligne, i);
                    switch (i) {
                        case 1:
                            MAJEmployRecu.setNom(curVal);
                            break;
                        case 2:
                            MAJEmployRecu.setPrenom(curVal);
                            break;
                        case 3:
                            MAJEmployRecu.setTel(curVal);
                            break;
                        case 4:
                            MAJEmployRecu.setAdresse(curVal);
                            break;
                        case 5:
                            MAJEmployRecu.setSpecialite(curVal);
                            break;
                        default:
                            break;
                    }
                }
                switch (colonne) {
                    case 0:
                        MAJEmployRecu.setNo_employe(Integer.parseInt(currentVal));
                        break;
                    case 1:
                        MAJEmployRecu.setNom(currentVal);
                        break;
                    case 2:
                        MAJEmployRecu.setPrenom(currentVal);
                        break;
                    case 3:
                        MAJEmployRecu.setTel(currentVal);
                        break;
                    case 4:
                        MAJEmployRecu.setAdresse(currentVal);
                        break;
                    default:
                        break;
                }
                //l'instance modifiée de la classe Employé et ensuite envoyée pour update
                retourEmployeAll.update(MAJEmployRecu);
            }
            break;
            case "Chambre":{
                //créer l'objet Employe à envoyer pour l'update
                Chambre MAJEmployRecu = new Chambre();
                //regarde là où l'utilisateur effectue la modification dans le tableau
                int ligne = leTableau.getSelectedRow();//Si tu veut la cellule selectionnée, sinon une autre valeur
                int colonne = leTableau.getSelectedColumn();//Si tu veut la cellule selectionnée, sinon une autre valeur
                Object cellule = leTableau.getValueAt(ligne, colonne);
                String currentVal = (String) cellule;
                int curNo = (Integer) leTableau.getValueAt(ligne, 0); 
            //String code_service, int no_chambre, int surveillant, int nb_lits
                MAJEmployRecu.setNo_chambre(curNo);
                //puis les autres attributs String
                for (int i = 1; i < 4; i++) {
                    String curVal = (String) leTableau.getValueAt(ligne, i);
                    switch (i) {
                        case 1:
                            MAJEmployRecu.setNb_lits(Integer.parseInt(curVal));
                            break;
                        case 2:
                            MAJEmployRecu.setSurveillant(Integer.parseInt(curVal));
                            break;
                        case 3:
                            MAJEmployRecu.setCode_service(curVal);
                            break;  
                        default:
                            break;
                    }
                }
                switch (colonne) {
                    case 0:
                        MAJEmployRecu.setNo_chambre(Integer.parseInt(currentVal));
                        break;
                    case 1:
                            MAJEmployRecu.setNb_lits(Integer.parseInt(currentVal));
                            break;
                        case 2:
                            MAJEmployRecu.setSurveillant(Integer.parseInt(currentVal));
                            break;
                        case 3:
                            MAJEmployRecu.setCode_service(currentVal);
                            break;  
                        default:
                            break;      
                }
                //l'instance modifiée de la classe Employé et ensuite envoyée pour update
                retourChambreAll.update(MAJEmployRecu);
            }
                
            default: ;
        }
    }

    //insertion  
    private void jButton2ActionPerformed(java.awt.event.ActionEvent evt) {
  //insertion=> je donne automatiquement un N0 d'employe.
        // ensuite c'est l'utilisateur qui l'update sur le tableau
        //int lenghtEntete = modelTabGlobal.getColumnCount();
        //je récupère le N°employé maximal
        int max = (Integer) leTableau.getValueAt(0, 0);
        for (int j = 1; j < modelTabGlobal.getRowCount(); j++) {
            if (max < (Integer) leTableau.getValueAt(j, 0)) {
                max = (Integer) leTableau.getValueAt(j, 0);
            }
        }
        //Je créé un object Employe avec son numéro := max+1
        Employe nouvelEmploye = new Employe();
        nouvelEmploye.setNo_employe(max + 1);
        nouvelEmploye.setNom("data");
        nouvelEmploye.setPrenom("data");
        nouvelEmploye.setAdresse("data");
        nouvelEmploye.setTel("data");
        //je créé  un tableau d'Objet pour le model du JTable 
        Object newRow[] = { //objectTab permet de remplir le JTable
            nouvelEmploye.getNo_employe(),
            nouvelEmploye.getNom(),
            nouvelEmploye.getPrenom(),
            nouvelEmploye.getTel(),
            nouvelEmploye.getAdresse()
        };
        //si la création fonctionne := on ajoute la nouvelle ligne au modele
        if (retourEmployeAll.create(nouvelEmploye)) {
            modelTabGlobal.addRow(newRow);
        }
    }

    //suppression
    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {
        // SUPPRESSION :=> basée sur le N° de la valeur.
        //attention=> irréversible.//il est préférable de Supprimer une ligne précedemment ajoutée
        int entreeLigneASupprimer = Integer.parseInt(jTextField1.getText());
        int curNo;
        //On rempli l'object Employe à supprimer => seul le Numero_emp est utile
        Employe EmployASuppr = new Employe();
        EmployASuppr.setNo_employe(entreeLigneASupprimer);

        //Test sur toutes les lignes
        for (int i = 0; i < modelTabGlobal.getRowCount(); i++) {
            curNo = (Integer) leTableau.getValueAt(i, 0);
            System.out.println(curNo);
            if (curNo == entreeLigneASupprimer) {
                if (retourEmployeAll.delete(EmployASuppr)) {
                    modelTabGlobal.removeRow(i);
                }
            }
        }
    }

    private void jButton4ActionPerformed(java.awt.event.ActionEvent evt) {
        //AIDE :=> ouvre une JFrame qui indique les actions possibles avec les bouttons et sur le tableau
        ReadMeConnection aideUtil = new ReadMeConnection("MAJ");
    }

    private void jTextField1ActionPerformed(java.awt.event.ActionEvent evt) {

    }

    // Variables declaration - do not modify                     
    private javax.swing.JButton jButton1;
    private javax.swing.JButton jButton2;
    private javax.swing.JButton jButton3;
    private javax.swing.JButton jButton4;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JTextField jTextField1;
    // End of variables declaration                   
}
